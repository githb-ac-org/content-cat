#!/usr/bin/env bash
#
# Content Cat - One command to run everything
#

set -e

# ══════════════════════════════════════════════════════════════════════════════
# COLORS
# ══════════════════════════════════════════════════════════════════════════════

BOLD='\033[1m'
DIM='\033[2m'
RESET='\033[0m'

BR_BLACK='\033[0;90m'
BR_RED='\033[0;91m'
BR_GREEN='\033[0;92m'
BR_YELLOW='\033[0;93m'
BR_BLUE='\033[0;94m'
BR_MAGENTA='\033[0;95m'
BR_CYAN='\033[0;96m'
BR_WHITE='\033[0;97m'

# ══════════════════════════════════════════════════════════════════════════════
# UTILITIES
# ══════════════════════════════════════════════════════════════════════════════

command_exists() { command -v "$1" &>/dev/null; }
hide_cursor() { tput civis 2>/dev/null || true; }
show_cursor() { tput cnorm 2>/dev/null || true; }
clear_line() { printf "\r\033[K"; }

trap 'show_cursor' EXIT INT TERM

ok() { printf "  ${BR_GREEN}✓${RESET} %s\n" "$1"; }
info() { printf "  ${BR_BLUE}→${RESET} ${DIM}%s${RESET}\n" "$1"; }
warn() { printf "  ${BR_YELLOW}!${RESET} %s\n" "$1"; }

# Find available port starting from a given port
find_available_port() {
    local port=${1:-3000}
    local max=${2:-$((port + 100))}
    while lsof -i :"$port" &>/dev/null; do
        ((port++))
        [[ $port -gt $max ]] && break
    done
    echo "$port"
}

spinner() {
    local pid=$1
    local message=$2
    local spin='⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏'
    local i=0

    hide_cursor
    while kill -0 "$pid" 2>/dev/null; do
        printf "\r  ${BR_CYAN}%s${RESET} ${DIM}%s${RESET}" "${spin:i++%10:1}" "$message"
        sleep 0.08
    done
    clear_line
    show_cursor
}

run() {
    local message=$1
    shift
    ("$@") &>/dev/null &
    local pid=$!
    spinner $pid "$message"
    wait $pid
    local status=$?
    if [[ $status -eq 0 ]]; then
        printf "\r  ${BR_GREEN}✓${RESET} %s\n" "$message"
    else
        printf "\r  ${BR_RED}✗${RESET} %s\n" "$message"
        return $status
    fi
}

# ══════════════════════════════════════════════════════════════════════════════
# FIND PROJECT
# ══════════════════════════════════════════════════════════════════════════════

find_project() {
    if [[ -f "./package.json" ]] && grep -q '"name": "content-cat"' ./package.json 2>/dev/null; then
        echo "$(pwd)"
        return
    fi

    local locations=(
        "$HOME/content-cat"
        "$HOME/Content-Cat"
        "$HOME/projects/content-cat"
        "$HOME/dev/content-cat"
        "$HOME/Documents/content-cat"
        "/opt/content-cat"
    )

    for loc in "${locations[@]}"; do
        if [[ -f "$loc/package.json" ]] && grep -q '"name": "content-cat"' "$loc/package.json" 2>/dev/null; then
            echo "$loc"
            return
        fi
    done

    echo ""
}

# ══════════════════════════════════════════════════════════════════════════════
# SETUP FUNCTIONS
# ══════════════════════════════════════════════════════════════════════════════

# Get the host port a container is mapped to
get_container_port() {
    local container_name=$1
    local internal_port=$2
    docker port "$container_name" "$internal_port" 2>/dev/null | sed 's/.*://' | head -1
}

# Find available Docker ports (use existing container ports if running)
find_docker_ports() {
    # Default ports
    POSTGRES_PORT=5499
    REDIS_PORT=6379

    # If our PostgreSQL container is running, use its current port
    if docker ps --format '{{.Names}}' 2>/dev/null | grep -q "^content-cat-db$"; then
        local current_pg=$(get_container_port "content-cat-db" "5432")
        if [[ -n "$current_pg" ]]; then
            POSTGRES_PORT=$current_pg
        fi
    else
        # Container not running - find available port
        if lsof -i :$POSTGRES_PORT &>/dev/null; then
            POSTGRES_PORT=$(find_available_port 5499 5599)
        fi
    fi

    # If our Redis container is running, use its current port
    if docker ps --format '{{.Names}}' 2>/dev/null | grep -q "^content-cat-redis$"; then
        local current_redis=$(get_container_port "content-cat-redis" "6379")
        if [[ -n "$current_redis" ]]; then
            REDIS_PORT=$current_redis
        fi
    else
        # Container not running - find available port
        if lsof -i :$REDIS_PORT &>/dev/null; then
            REDIS_PORT=$(find_available_port 6379 6479)
        fi
    fi

    export POSTGRES_PORT REDIS_PORT
}

ensure_env() {
    # Find available ports first
    find_docker_ports

    if [[ -f ".env" ]]; then
        # Update existing .env with new ports if they changed (portable regex)
        local current_pg_port=$(sed -n 's/.*localhost:\([0-9]*\)\/contentcat.*/\1/p' .env 2>/dev/null | head -1)
        local current_redis_port=$(sed -n 's/.*redis:\/\/localhost:\([0-9]*\).*/\1/p' .env 2>/dev/null | head -1)
        current_pg_port=${current_pg_port:-5499}
        current_redis_port=${current_redis_port:-6379}

        if [[ "$current_pg_port" != "$POSTGRES_PORT" ]] || [[ "$current_redis_port" != "$REDIS_PORT" ]]; then
            # Update DATABASE_URL
            sed -i.bak "s|localhost:[0-9]*/contentcat|localhost:${POSTGRES_PORT}/contentcat|g" .env
            # Update REDIS_URL
            sed -i.bak "s|redis://localhost:[0-9]*|redis://localhost:${REDIS_PORT}|g" .env
            # Update port variables if they exist
            sed -i.bak "s|^POSTGRES_PORT=.*|POSTGRES_PORT=${POSTGRES_PORT}|g" .env
            sed -i.bak "s|^REDIS_PORT=.*|REDIS_PORT=${REDIS_PORT}|g" .env
            rm -f .env.bak

            if [[ "$current_pg_port" != "$POSTGRES_PORT" ]]; then
                info "PostgreSQL port: $current_pg_port → $POSTGRES_PORT"
            fi
            if [[ "$current_redis_port" != "$REDIS_PORT" ]]; then
                info "Redis port: $current_redis_port → $REDIS_PORT"
            fi
        fi
        return 0
    fi

    local session_secret=$(openssl rand -hex 32 2>/dev/null || head -c 64 /dev/urandom | base64 | tr -dc 'a-zA-Z0-9' | head -c 64)
    local cron_secret=$(openssl rand -hex 16 2>/dev/null || head -c 32 /dev/urandom | base64 | tr -dc 'a-zA-Z0-9' | head -c 32)
    local encryption_key=$(openssl rand -hex 32 2>/dev/null || head -c 64 /dev/urandom | base64 | tr -dc 'a-zA-Z0-9' | head -c 64)

    cat > .env << EOF
DATABASE_URL="postgresql://contentcat:contentcat@localhost:${POSTGRES_PORT}/contentcat?schema=public"
NODE_ENV="development"
SESSION_SECRET="${session_secret}"
SESSION_EXPIRY_DAYS=7
REDIS_URL="redis://localhost:${REDIS_PORT}"
CRON_SECRET="${cron_secret}"
ENCRYPTION_KEY="${encryption_key}"
POSTGRES_PORT=${POSTGRES_PORT}
REDIS_PORT=${REDIS_PORT}
EOF

    ok "Created .env"
}

ensure_deps() {
    [[ -d "node_modules/.pnpm" ]] && return 0

    if ! command_exists pnpm; then
        info "Installing pnpm..."
        if command_exists corepack; then
            corepack enable 2>/dev/null || true
            corepack prepare pnpm@latest --activate 2>/dev/null || npm install -g pnpm
        else
            npm install -g pnpm
        fi
    fi

    run "Installing dependencies" pnpm install --frozen-lockfile
}

detect_os() {
    if [[ "$OSTYPE" == "darwin"* ]]; then
        echo "macos"
    elif [[ -f /proc/version ]] && grep -qi microsoft /proc/version; then
        echo "wsl"
    else
        echo "linux"
    fi
}

start_docker() {
    local os=$(detect_os)

    if ! command_exists docker; then
        warn "Docker not installed"
        return 1
    fi

    if docker info &>/dev/null 2>&1; then
        return 0
    fi

    info "Starting Docker..."

    case $os in
        macos)
            open -a Docker 2>/dev/null || true
            local count=0
            hide_cursor
            while ! docker info &>/dev/null 2>&1; do
                printf "\r  ${BR_CYAN}⠋${RESET} ${DIM}Waiting for Docker Desktop...${RESET}"
                sleep 2
                ((count++))
                if [[ $count -gt 30 ]]; then
                    clear_line
                    show_cursor
                    warn "Docker timeout"
                    return 1
                fi
            done
            clear_line
            show_cursor
            ;;
        wsl)
            warn "Start Docker Desktop in Windows"
            return 1
            ;;
        linux)
            sudo systemctl start docker 2>/dev/null || true
            sleep 2
            ;;
    esac

    docker info &>/dev/null 2>&1
}

start_services() {
    local db_running=$(docker ps --format '{{.Names}}' 2>/dev/null | grep -c "content-cat-db" || echo "0")
    local redis_running=$(docker ps --format '{{.Names}}' 2>/dev/null | grep -c "content-cat-redis" || echo "0")

    if [[ "$db_running" == "1" ]] && [[ "$redis_running" == "1" ]]; then
        ok "Services running"
        return 0
    fi

    run "Starting PostgreSQL & Redis" bash -c "docker compose up -d postgres redis 2>/dev/null"

    # Wait for healthy
    local count=0
    while ! docker exec content-cat-db pg_isready -U contentcat &>/dev/null 2>&1; do
        sleep 1
        ((count++))
        [[ $count -gt 30 ]] && break
    done
    sleep 1
}

ensure_schema() {
    [[ ! -d "node_modules/.prisma" ]] && pnpm prisma generate &>/dev/null

    if ! pnpm prisma db execute --stdin <<< "SELECT 1 FROM \"User\" LIMIT 1;" &>/dev/null 2>&1; then
        run "Setting up database" pnpm prisma db push
    else
        ok "Database ready"
    fi
}

# ══════════════════════════════════════════════════════════════════════════════
# MAIN
# ══════════════════════════════════════════════════════════════════════════════

main() {
    INSTALL_DIR=$(find_project)

    # Not installed - run installer
    if [[ -z "$INSTALL_DIR" ]]; then
        echo ""
        printf "  ${BR_YELLOW}Content Cat not found${RESET}\n"
        echo ""
        info "Installing..."
        echo ""

        INSTALLER_URL="https://raw.githubusercontent.com/KenKaiii/content-cat/main/scripts/install.sh"

        if command_exists curl; then
            bash <(curl -fsSL "$INSTALLER_URL")
        elif command_exists wget; then
            bash <(wget -qO- "$INSTALLER_URL")
        else
            printf "  ${BR_RED}✗${RESET} curl or wget required\n"
            exit 1
        fi
        exit 0
    fi

    cd "$INSTALL_DIR"

    # Banner
    clear
    echo ""
    printf "${BR_MAGENTA}"
    cat << 'EOF'
   ██████╗ ██████╗ ███╗   ██╗████████╗███████╗███╗   ██╗████████╗
  ██╔════╝██╔═══██╗████╗  ██║╚══██╔══╝██╔════╝████╗  ██║╚══██╔══╝
  ██║     ██║   ██║██╔██╗ ██║   ██║   █████╗  ██╔██╗ ██║   ██║
  ██║     ██║   ██║██║╚██╗██║   ██║   ██╔══╝  ██║╚██╗██║   ██║
  ╚██████╗╚██████╔╝██║ ╚████║   ██║   ███████╗██║ ╚████║   ██║
   ╚═════╝ ╚═════╝ ╚═╝  ╚═══╝   ╚═╝   ╚══════╝╚═╝  ╚═══╝   ╚═╝
EOF
    printf "${RESET}"
    printf "${BR_CYAN}"
    cat << 'EOF'
   ██████╗ █████╗ ████████╗
  ██╔════╝██╔══██╗╚══██╔══╝
  ██║     ███████║   ██║
  ██║     ██╔══██║   ██║
  ╚██████╗██║  ██║   ██║
   ╚═════╝╚═╝  ╚═╝   ╚═╝
EOF
    printf "${RESET}"
    echo ""

    # Find available port
    local PORT=$(find_available_port)

    # Setup
    ensure_env
    ensure_deps

    if start_docker; then
        start_services
        sleep 1
        ensure_schema
    fi

    # Check if first-time setup is needed
    local SETUP_URL=""
    if command_exists curl; then
        # Start server briefly to check setup status
        pnpm dev --port "$PORT" &>/dev/null &
        local DEV_PID=$!
        sleep 3

        local SETUP_CHECK=$(curl -s "http://localhost:${PORT}/api/auth/setup" 2>/dev/null || echo '{}')
        if echo "$SETUP_CHECK" | grep -q '"setupRequired":true'; then
            SETUP_URL="/login"
        fi

        kill $DEV_PID 2>/dev/null || true
        wait $DEV_PID 2>/dev/null || true
    fi

    printf "  ${DIM}Open in browser:${RESET}  ${BR_WHITE}http://localhost:${PORT}${SETUP_URL}${RESET}\n"
    if [[ -n "$SETUP_URL" ]]; then
        printf "  ${BR_YELLOW}!${RESET} ${DIM}First time? Create your account to get started${RESET}\n"
    fi
    echo ""
    printf "  ${BR_BLACK}─────────────────────────────────────────────────────────────────${RESET}\n"
    echo ""

    exec pnpm dev --port "$PORT"
}

main "$@"
